[{"title":"chap3 线性神经网络","url":"/2021/11/22/deeplearning-0/","content":"\n\n\n[本章视频地址](https://www.bilibili.com/video/BV1PX4y1g7KC?spm_id_from=333.999.0.0)，[本章讲义地址](https://zh-v2.d2l.ai/chapter_linear-networks/index.html)\n\n> 在介绍深度神经网络之前，我们需要了解神经网络训练的基础知识。在本章中，我们将介绍神经网络的整个训练过程，包括：定义简单的神经网络架构、数据处理、指定损失函数和如何训练模型。经典统计学习技术中的线性回归和 softmax 回归可以视为*线性*神经网络。为了更容易学习，我们将从这些经典算法开始，向你介绍神经网络的基础知识。这些知识将为本书其他部分中更复杂的技术奠定基础。\n\n<!--more-->\n\n# 线性回归 (linear regression)\n\n线性回归 (linear regression) 基于几个简单的假设：\n\n**首先**，假设自变量 $x$ 和因变量 $y$ 之间的关系是线性的，即 $y$ 可以表示为 $x$ 中元素的加权和，这里通常允许包含观测值的一些噪声；**其次**，我们假设任何噪声都比较正常，如噪声遵循正态分布。\n\n\n\n## 线性模型\n\n线性假设指目标可以表示为特征的加权和：$y=w_1x_1+w_2x_2+w_3x_3 +...+ b$\n\n$w_i$ 称为权重（weight），$b $称为*偏置*（bias），或称为*偏移量*（offset）、*截距*（intercept）。权重决定了每个特征对我们预测值的影响。偏置是指当所有特征都取值为 0 时，预测值应该为多少。\n\n对于特征集合$X$，预测值 $\\hat y \\in R_n$ 可以通过**矩阵-向量**乘法表示为：$\\hat y=Xw+b$\n\n训练数据：$X=[x_1,x_2,...,x_n]^T,y=[y_1,y_2,...y_n]^T$\n\n需要学习的参数：$W=[w_1,w_2,...,w_n]^T,b$\n\n**线性模型可以看作是单层神经网络**\n\n```mermaid\ngraph BT\n\to1\n\tx1-->o1\n\tx2-->o1\n\tx3[...]-->o1\n\txd-->o1\n```\n\n## 损失函数\n\n**定义损失** -> 平方损失：$l(y,y')=\\frac{1}{2}(y-\\hat y)^2$\n\n**损失函数**-> 在训练集的 n 个样本上的损失均值：$L(w,b)=\\frac{1}{n}∑_{i=1}^{n}l^{(i)}(w,b)=\\frac{1}{2n}∑_{i=1}^{n}(w^⊤x^{(i)}+b−y{(i)})^2$\n\n**训练过程** -> 最小化损失来学习参数：$w^*,b^*=arg~min_{w,b} ~ l(\\textbf{X,y,w},b)$\n\n\n\n## 解析解（显示解）\n\n解析解指可以通过数学公式简单地表达出来的解。\n\n1. 将偏差加入权重\n2. 损失是凸函数，所以梯度值为 0 的地方就是最优解。\n\n> 像线性回归这样的简单问题存在解析解，但并不是所有的问题都存在解析解。解析解可以进行很好的数学分析，但解析解的限制很严格，导致它无法应用在深度学习里。\n\n\n\n## 基础优化方法\n\n当一个问题没有最优解时，应该使用什么方法来优化模型的预测结果（即学习参数）呢？\n\n下面介绍几种基础的优化方法 :)\n\n### 梯度下降\n\n*梯度下降*（gradient descent）方法几乎可以优化所有深度学习模型。它通过不断地在**损失函数递减的方向**上**更新参数**来降低误差。\n\n#### 优化过程\n\n1. 挑选（如，随机初始化）待学习参数的初始值 $w_0$\n\n2. 重复迭代参数 t=1,2,3…\n\n   $w_t=w_{t-1}-\\eta \\frac{\\partial l}{\\partial  w_t-1}$\n\n   - 沿着梯度方向将增加损失函数的值，负梯度方向即为损失函数值减小的方向。\n   - 学习率 $\\eta$（learning rate）：步长的超参数\n   - $l$ ：损失函数\n\n   \n\n**小批量随机梯度下降**：\n\n梯度下降最简单的用法是计算损失函数（数据集中所有样本的损失均值）关于模型参数的导数（在这里也可以称为梯度）。**但实际中的执行可能会非常慢**：因为在每一次更新参数之前，我们必须遍历整个数据集。因此，我们通常会在每次需要计算更新的时候**随机抽取一小批样本**，这种变体叫做*小批量随机梯度下降*（minibatch stochastic gradient descent）。\n\n","tags":["DeepLearning"],"categories":["跟李沐学 AI"]},{"title":"Attention Is All You Need","url":"/2021/11/19/transformer/","content":"\n本文为 [transformer模型原论文](https://arxiv.org/abs/1706.03762)的学习笔记。\n\n## 预备知识\n\n**CNN，RNN，LSTM都是什么？**\n\n[参考文章](https://cloud.tencent.com/developer/article/1523622)\n\n<!-- more -->\n#### **卷积神经网络（Convolutional Neural Network, CNN）**\n\nCNN 是一种前馈神经网络，通常由一个或多个卷积层（Convolutional Layer）和全连接层（Fully Connected Layer，对应经典的 NN）组成，此外也会包括池化层（Pooling Layer）。\n\nCNN 的结构使得它易于利用输入数据的二维结构。\n\n> 注意：前馈神经网络（Feedforward NN）指每个神经元只与前一层的神经元相连，数据从前向后单向传播的 NN。其内部结构不会形成有向环（对比后面要讲到的 RNN/LSTM）。 它是最早被发明的简单 NN 类型，前面讲到的 NN、DNN 都是前馈神经网络。\n\n每个卷积层由若干卷积单元组成——可以想象成经典 NN 的神经元，只不过激活函数变成了卷积运算。\n\n卷积运算是有其严格的数学定义的。不过在 CNN 的应用中，卷积运算的形式是数学中卷积定义的一个特例，它的目的是提取输入的不同特征。\n\n一般情况下，从直观角度来看，CNN 的卷积运算，就是下图这样：\n\n\n{% asset_img A1.gif This is an CNN image %}\n\n> 上图中左侧的蓝色大矩阵表示输入数据，在蓝色大矩阵上不断运动的绿色小矩阵叫做卷积核，每次卷积核运动到一个位置，它的每个元素就与其覆盖的输入数据对应元素相乘求积，然后再将整个卷积核内求积的结果累加，结果填注到右侧红色小矩阵中。 卷积核横向每次平移一列，纵向每次平移一行。最后将输入数据矩阵完全覆盖后，生成完整的红色小矩阵就是卷积运算的结果。\n\n\n\nCNN 结构相对简单，可以使用反向传播算法进行训练，这使它成为了一种颇具吸引力的深度学习网络模型。\n\n{% asset_img A2.jpg This is an backword image %})\n\n除了图像处理，CNN 也会被应用到语音、文本处理等其他领域。\n\n#### **循环神经网（Recurrent Neural Network，RNN）**\n\nRNN，循环神经网络，也有人将它翻译为**递归神经网络**。从这个名字就可以想到，它的结构中存在着“环”。\n\n确实，RNN 和 NN/DNN 的数据单一方向传递不同。RNN 的神经元接受的输入除了“前辈”的输出，还有自身的状态信息，其状态信息在网络中循环传递。\n\nRNN 的结构用图形勾画出来，是下图这样的：\n\n{% asset_img A3.jpg This is an RNN image %}\n\n图1\n\n> 注意：图中的 AA 并不是一个神经元，而是一个神经网络块，可以简单理解为神经网络的一个隐层。\n\nRNN 的这种结构，使得它很适合应用于序列数据的处理，比如文本、语音、视频等。这类数据的样本间存在顺序关系（往往是时序关系），每个样本和它之前的样本存在关联。\n\nRNN 把所处理的数据序列视作时间序列，在每一个时刻 $t$，每个 RNN 的神经元接受两个输入：当前时刻的输入样本 $x_t$，和上一时刻自身的输出 $h_{t-1}$\n\n$t 时刻输出：h_t=F_{\\theta}(h_{t-1},x_t)$\n\n图1经过进一步简化，将隐层的自连接重叠，就成了下图：\n\n{% asset_img A4.jpg This is an siplifiedRNN image %}\n\n图2\n\n上图展示的是最简单的 RNN 结构，此外 RNN 还存在着很多变种，比如双向 RNN（Bidirectional RNN），深度双向 RNN（Deep Bidirectional RNN）等。\n\nRNN 的作用最早体现在手写识别上，后来在语音和文本处理中也做出了巨大的贡献，近年来也不乏将其应用于图像处理的尝试。\n\n#### **长短时记忆（Long Short Term Memory，LSTM）**\n\nLSTM 可以被简单理解为是一种神经元更加复杂的 RNN，处理时间序列中当间隔和延迟较长时，LSTM 通常比 RNN 效果好。\n\n相较于构造简单的 RNN 神经元，LSTM 的神经元要复杂得多，每个神经元接受的输入除了当前时刻样本输入，上一个时刻的输出，还有一个元胞状态（Cell State），LSTM 神经元结构请参见下图：\n\n{% asset_img LSTM.jpg This is an CNN image %}\n\nLSTM 神经元中有三个门：遗忘门，输入门和输出门。\n\n遗忘门（Forget Gate)：接受 xt 和  ht-1 为输入，输出一个 0 到 1 之间的值，用于决定在多大程度上保留上一个时刻的元胞状态 ct-1。1表示全保留，0表示全放弃。\n\n输入门（Input Gate）: 用于决定将哪些信息存储在这个时刻的元胞状态 ct中。\n\n输出门（Output Gate）：用于决定输出哪些信息。\n\n\n\n![lstm-a]({% asset_img LSTM-A.jpg This is an LSTM-A image %}/LSTM-A.jpg)\n\n【LSTM 结构图】\n\n{% asset_img RNN-A.jpg This is an RNN-A.jpg image %}\n\n【RNN 结构图】\n\n> 注意：如果把 LSTM 的遗忘门强行置0，输入门置1，输出门置1，则 LSTM 就变成了标准 RNN。\n\n可见 LSTM 比 RNN 复杂得多，要训练的参数也多得多。\n\n但是，LSTM 在很大程度上缓解了一个在 **RNN 训练中非常突出的问题：梯度消失/爆炸（Gradient Vanishing/Exploding）**。这个问题不是 RNN 独有的，深度学习模型都有可能遇到，但是对于 RNN 而言，特别严重。\n\n梯度消失和梯度爆炸虽然表现出来的结果正好相反，但出现的原因却是一样的。\n\n因为神经网络的训练中用到反向传播算法，而这个算法是基于梯度下降的——在目标的负梯度方向上对参数进行调整。如此一来就要对激活函数求梯度。\n\n又因为 RNN 存在循环结构，因此激活函数的梯度会乘上多次，这就导致：\n\n- 如果梯度小于1，那么随着层数增多，梯度更新信息将会以指数形式衰减，即发生了梯度消失（Gradient Vanishing）；\n- 如果梯度大于1，那么随着层数增多，梯度更新将以指数形式膨胀，即发生梯度爆炸（Gradient Exploding）。\n\n因为三个门，尤其是遗忘门的存在，LSTM 在训练时能够控制梯度的收敛性，从而梯度消失/爆炸的问题得以缓解，同时也能够保持长期的记忆性。\n\n果然，LSTM 在语音处理、机器翻译、图像说明、手写生成、图像生成等领域都表现出了不俗的战绩。\n\n\n\n## Abstract\n\n段落大意：\n\n主流的序列转录模型主要依赖于循环或者卷积神经网络，它们一般使用 encoder-decoder 架构。在性能最好的这些模型中，通常会在 encoder 和 decoder 之间使用注意力机制。我们提出了一个新的简单的网络架构，Transformer，它仅依赖于注意力机制，而没有用循环或者卷积。通过两个机器翻译实验的验证，证明 Transformer 能比现有的模型效果更好且训练时间更快，最后写明 Transformer 也能很好的泛化到其他的任务上。\n\n总结：\n\n前人工作+本篇文章的创新点+模型的性能很棒\n\n\n\n## Conclusion\n\n段落大意：\n\n我们首次提出了一个仅依赖于注意力机制的模型，Transformer。它用 multi-head self-attention 层替换了前人用的循环层。\n\n在机器翻译的任务上，Transformer 起到了很好的效果。\n\n基于纯注意力机制的模型在机器翻译任务上取得的优越效果令人激动，我们认为他还能适用在图片/语音/视频等材料的研究任务中，making generation less sequential 也是一个新的研究目标。\n\n总结：\n\n主要贡献是提出了仅依赖于注意力机制的模型，重点在 multi-head self-attention 层。\n\n展望未来：这种方法还能泛化到其他任务中。\n\n\n\n## Introduction\n\n段落大意：\n\n> 基本是 Abstract 的扩充\n\n","tags":["论文阅读"],"categories":["跟李沐学 AI"]},{"title":"实用机器学习","url":"/2021/11/19/ML/","content":"\n\n本文为学习李沐老师[《实用机器学习》](https://space.bilibili.com/1567748478/channel/seriesdetail?sid=358496)这门课程的笔记。\n\n<!-- more -->\n## overview\n\n1. **任务分类**\n\n    监督学习，半监督学习，无监督学习，强化学习\n\n2. **任务组成部分**\n\n    模型：给定输入，有输出\n\n    损失函数：模型预测值和真实值的差距如何定量计算\n\n    目标函数：模型训练过程中的优化目标，如，使得模型预测的值与真实值的差距尽量小\n\n    模型优化：调整参数，最小化损失\n\n3. **模型分类**：\n\n    决策树；\n\n    线性模型：根据输入的线性组合来做决定。\n\n    核方法：用不同的核函数来衡量两个样本之间的相似度，来达到非线性的效果。\n\n    神经网络；\n\n## 决策树\n\n### 优缺点\n\n优点：\n\n1. 模型可解释。\n2. 可以处理数值型和类别型的特征，可分类可回归。\n3. 不太需要调参，可以广泛应用于工业界。\n\n缺点：\n\n1. 不稳定，受数据的噪声影响大 - embedding\n\n2. 复杂树导致过拟合 - 剪枝\n\n3. 不好并行计算，性能吃亏\n\n\n\n### 随机森林\n\n**随机生成多个决策树**，决策树训练彼此独立，用投票法或加权平均做出最后决定。\n\n **如何随机训练单棵树？**\n\n1. bagging：数据随机采样，有放回。\n2. randomly：随机选取一些特征。\n\n### 梯度提升（Gradient Boosting Decision Trees ）\n\n**序列化生成若干树**。各个决策树中彼此不独立。\n\n1. 设 $t=1 … , F_t(x)$ 是前 $t-1$ 棵树的函数输出的和。\n\n2. 在 $t$ 时刻训练新的树 $f_t$，训练数据集为残差数据集：$[(x_i,y_i-F_t(x_i))]_{i=1...}$，用来预测当前模型和真实数据之间的误差。\n\n3. 那么，新的模型为： $F_{t+1}=F_t(x)+f_t(x)$\n\n> 残差等同于平均均方误差的负梯度 $- \\partial L/\\partial F$。\n>\n> L 为 F 的预测值和真实值之间的均方误差。后续的决策树都在拟合均方误差的负梯度->梯度下降。\n\n","tags":["MachineLearning"],"categories":["跟李沐学 AI"]},{"title":"如何快速读论文","url":"/2021/11/19/read-paper/","content":"\n1. 明确目的\n2. 做笔记\n\n<!-- more -->\n\n### 论文结构\n\n1. title\n2. abstract\n3. intro\n4. method\n5. exp\n6. conclusion\n\n### pass1\n\n先读摘要，然后直接看结论。\n\n再去看看实验部分的图和表，以及方法中的图表。\n\n> 这样可以快速了解到这篇文章大致做了什么，是否适合自己。\n\n### pass2\n\n顺着从 intro 往下读，**关键抓住图表**，**图中的细节都需要了解和掌握**。\n\n作者提出的方法和其他人提出的方法之间有什么区别。\n\n圈出论文中引用的，但是自己不知道的文献。\n\n> 这一步可以了解到作者具体做了什么样的工作，以及这篇文章对自己的难易程度。\n>\n> 如果发现本篇文章太难，但是又是自己感兴趣的内容，那可以去读圈出来的前人的工作。读完之后再回来读。\n\n### pass3\n\n需要知道每一句话，每个字都在讲什么。\n\n提出了什么问题，用什么方法解决这个问题，如何实现的，如果换我来我可以怎么来解决这个问题？\n\n脑补实验过程，好像自己做了这个工作。\n\n合起来文章之后能复述这个工作。","tags":["论文阅读"],"categories":["跟李沐学 AI"]},{"title":"计算机网络复习 - 无线和移动网络","url":"/2021/03/01/ComputerNetwork-chap6/","content":"\n# IEEE 802.11 无线局域网\n\n**802.11 无线局域网架构：**\n\n802.11 无线 LAN 的基本组成单元是基本服务集（BSS）\n\n<!-- more -->\n一个 BSS 包括:\n- 若干无线终端\n- 一个无线接入点 AP\n每个无线接口（终端及 AP）均有一个全局唯一的 MAC 地址\n\n  {% asset_img 1.PNG This is an 802.11 image %}\n**802.11 信道与关联：**\n\n802.11 将通信频段划分成若干信道，每个 BSS 分配一个信道：\n- 管理员安装 AP 时，为 AP 分配一个**服务集标识符（SSID）**，并选择 AP 使用的信道\n- 相邻 AP 使用的信道**可能相互干扰**\n主机**必须与一个 AP 关联**：\n- 扫描信道，监听各个 AP 发送的信标帧（包含 AP 的 SSID 和 MAC 地址）\n\n    > 主动扫描：\n    >\n    > 1. 主机广播**探测请求帧**\n    > 2. AP 发送探测**响应**帧\n    > 3. 主机从收到的探测响应中**选择一个 AP 发送关联请求**\n    > 4. AP 发送关联响应帧\n    >\n    > 被动扫描：\n    >\n    > 1. 主机监听 AP 发送的信标帧\n    > 2. 主机选择一个 AP 发送关联请求帧\n    > 3. AP 向主机发送关联响应帧\n\n- 选择一个 AP 进行关联（可能需要身份鉴别）\n\n- 使用 DHCP 获得 AP 所在子网中的一个IP地址\n\n# 802.11: 多路访问控制\n\n802.11：基于 CSMA - 发送数据前监听信道。\n\n特点：发前监听，边发边听（最小帧长），冲突避让（BEB）。\n\n- 避免与正在进行传输的其他结点冲突\n\n802.11：不能像 CSMA/CD 那样，边发送，边检测冲突。\n\n- 无线信道很难实现：无线网络中，信号强度急剧衰减。\n\n- 无法侦听到所有可能的冲突：隐藏站、信号衰落\n\n    > 例如：\n    >\n    >   {% asset_img 2.PNG This is an 802.11eg image %}\n    >\n    > A-B、B-C 之间可以正常传输，A/C 之间有障碍物，遮挡了信号的传播，导致 A-C 之间的信号无法传输，若 A,C 同时和 B 传输数据，则会出现冲突。\n\n- 目标：**避免冲突 CSMA/C(illision)A(voidance)** （只能避免数据帧的冲突）\n\n##  MAC 协议：CSMA/CA\n\n### sender/receiver 工作流程\n\n**802.11 sender：**\n\n1. if 监听信道空闲了 **DIFS** 时间 then\n\n    发送整个帧（无同时检测冲突，即 CD（collision detection）\n\n2. if 监听到信道忙 then\n\n    开始随机退避计时\n\n    信道忙，计时冻结\n\n    当信道空闲时，计时器倒计时\n\n    当计时器超时时，发送帧\n\n    **if 没有收到 ACK then**\n\n    ​\t增加随机退避的间隔时间\n\n    重复第 2 步\n\n**802.11 receiver：**\n\n- if 正确接收帧\n\n    延迟 SIFS（< DIFS） 时间之后，向发送端发送 ACK （由于存在隐藏站问题）\n\n> 802.11 利用帧间间隔时间的长短来区分数据的优先级，间隔时间越长，优先级越低。\n>\n> 例如，DIFS 比 SIFS 长，说明 数据帧（data）的优先级低于 ACK 的优先级。\n\n  {% asset_img 3.PNG This is an sender-receiver image %}\n\n### 如何实现冲突避免？\n\n**基本思想：**\n\n允许发送端 **预约** 信道，而不是随机发送数据帧，从而避免长数据帧的冲突。\n\n- 发送端首先利用  CSMA 向 BS（基站） 发送一个**很短**的 **RTS** 帧\n\n    RTS （request to send）帧仍然有可能彼此冲突，但 RTS 帧很短，\n\n- BS 广播一个 **CTS**（clear to send） 帧作为对 RTS 的响应\n\n- CTS 可以被 **所有节点** 接收\n\n    可以消除隐藏站的影响\n\n    发送端可以发送数据帧\n\n    其他结点推迟发送\n\n**利用很小的预约帧，彻底避免数据帧冲突。**\n\n举个栗子：\n\n  {% asset_img 4.PNG This is an e.g. image %}\n\n\n\n### 802.11 MAC 帧\n\n  {% asset_img 5.PNG This is an MACframe image %}\n\n  {% asset_img 6.PNG This is an MACframe2 image %}","tags":["计算机网络"],"categories":["复习笔记"]},{"title":"计算机网络复习 - 链路层","url":"/2021/02/26/ComputerNetwork-chap5/","content":"\n# 综述\n通过这一章的学习，我们需要：\n理解数据链路层服务原理。\n- 差错检测和纠正\n- 共享广播信道: 多址接入\n- 链路层编址\n- 可靠传输、流量控制：done!\n了解链路层的实现。\n- 以太网\n- 点对点协议 PPP\n    <!--more-->\n\n# 链路层简介\n\n网络层：\n\n- 选路：确定从源路由器到目的路由的路径\n- 转发：路由器将数据报从一个端口转移到另一个端口\n\n链路层：\n\n- 将数据报从一个结点传输到相邻的下一个结点。\n\n    > 源主机->源路由器 -> 下一跳路由器 -> … -> 目的路由器 -> 目的主机\n\n**一些术语**：\n\n- 节点（nodes）：主机和路由器都统称为节点\n\n- 链路（links）：连接相邻节点的通信信道\n\n    > 包括：有限链路，无线链路，局域网\n\n- 帧（frame）：链路层分组称为帧。\n\n**链路层服务：**\n\n1. 组帧（framing）：\n\n    > 封装数据报构成数据帧（添加首部和尾部）\n    >\n    > 以及从帧中解封装数据报\n\n2. 链路接入（link access）：\n\n    > 在广播信道上协调各个节点的发送行为。\n    >\n    > 帧首部的 MAC 地址，用于标识帧的源和目的（不同于 IP 地址）\n\n3. 相邻结点间的可靠交付：\n\n    > 通过确认、重传等机制确保接收节点正确收到每一个帧。\n\n4. 流量控制：\n\n    > 协调相邻的发送节点和接收\n\n5. 差错检测:\n\n    > 接收端检测到差错：通知发送端重传或者直接丢弃帧。\n\n6. 差错纠正：\n\n    > 接收端直接纠正比特差错。\n\n7. 全双工和半双工通信控制：\n\n    > 全双工：链路两端节点**同时**双向传输。\n    >\n    > 半双工：两路两端节点**交替**双向传输。\n\n**链路层在哪实现？**\n\n- 路由器：链路层内在线卡中实现。\n\n- 主机：链路层主体部分在网络适配器（网卡）中实现。\n\n    网卡连接物理媒体，所以兼具物理层功能。\n\n    >  链路层由硬件和软件实现：\n    >\n    > - 网卡中的控制器芯片：组帧、链路接入、检错、可靠交付、流量控制等。\n    > - 主机上的链路层软件：与网络层接口，激活控制器硬件、响应控制器中断等。\n\n# 差错检测和纠正\n\n  {% asset_img 1.PNG This is an error detective image %}\n\n## 如何检测与纠正错误？\n\n- 码字（codeword）：由 m 比特的数据加上 r 比特的冗余位（校验位）构成\n\n- 有效编码集：由 2m 个符合编码规则的码字组成\n\n- **检错**：若收到的码字为无效码字，判定出现传输错误\n\n- **海明距离**（Hamming Distance）：两个码字的对应位取值不同的位数\n\n- **纠错**：将收到的无效码字纠正到距其最近的有效码字\n\n    > 检错码与纠错码的能力都是有限的！\n\n- **编码集的海明距离**：编码集中任意两个有效码字的海明距离的**最小值**。\n- **检错能力**：为检测出所有 **d** 比特错误，编码集的海明距离至少应为 **d+1**\n- **纠错能力**：为纠正所有 **d** 比特错误，编码集的海明距离至少应为 **2d+1**\n\n## 奇偶校验\n\n**单比特奇偶校验**：检测单比特错误。\n\n**二维奇偶校验：**\n\n> 检测奇数位差错、部分偶数位差错。\n>\n> 纠正同一行/列的奇数位错。\n\n## Checksum 校验和\n\n发送端：\n\n- 将数据（校验内容）划分为 16 位二进制序列\n- 求和：如果遇到最高位进位 1，则返回最低位继续加\n- 校验和 = 和的反码\n- 放入分组 UDP/TCP/IP 的校验和字段\n\n接收端：\n\n- 与发送端相同算法计算\n\n- 得到的 checksum ：\n\n    16 位全 0 （或 sum 16 位为 1）： 无措\n\n    否则有错\n\n## 循环冗余校验码 CRC\n\nCRC 是一种多项式编码，它将位串看成一个一元多项式的系数。\n\n信息多项式 M(x)：由 m 个信息比特为系数构成的多项式\n\n冗余多项式 R(x)：由 r 个冗余比特为系数构成的多项式\n\n码多项式 T(x)：在 m 个信息比特后加上 r 个冗余比特构成的码字所对应的多项式，表达式为 $T(x) = x^r·M(x) + R(x)$\n\n> 模 2 除法 == 按位异或 XOR == 相同为 0 ，不同为 1\n\n生成多项式 G(x)：双方确定用来计算 R(x) 的一个多项式，最高 r 次幂。\n\n**编码方法**：$R(x) = x^r·M(x) ÷ G(x) $的余式\n\n**检验方法**：若 $T(x) ÷G(x)$ 的余式为 0，判定传输正确\n\nCRC码检错能力极强，可用硬件实现，是应用最广泛的检错码。\n\n  {% asset_img 2.PNG This is an CRC image %}\n\n**每个 CRC 标准都能检测小于 r+1 比特的突发差错。**\n\n**在适当的假设下，长度大于 r+1 比特的突发差错以概率 $1- 0.5^r$ 被检测到。**\n\n**循环码性质：**\n\n⑴由任何多于一项的生成多项式g(x)产生的循环码能够检测所有单个错误；\n\n⑵每个被(1+x)除尽的多项式都具有偶数项。若生成多项式g(x)具有偶数项，则由它产生的编码就能检测所有奇数个错误；\n\n⑶若码长n不大于生成多项式g(x)的指数e(即n≤e)，则由g(x)产生的码能够检测所有单个和两个错码；\u000bg(x)的指数e：e是使g(x)能除尽xe+1的最小正整数；\n\n⑷若码长n不大于g1(x)的指数，则由生成多项式g(x)=(x+1)g1(x)产生的码能检测所有单个、两个及三个错误；\n\n⑸由(n-m)次多项式产生的任一循环码，能检测所有长度不超过(n-m)的突发错误；\n\n⑹ 长度为b>(n-m)的突发错误中：\u000b若b=n-m+1，则不能检测部分占2 ^-(n-m-1) ；\u000b若b>n-m+1，则不能检测部分占2^ -(n-m) 。\n\n> 为什么 G = 1011 能够检测出任何单比特错误？\n>\n> - 某一位出错相当于在二进制的那一位+1，对于整个接收到的二进制数来说相当于+2^i ，2^i 不能被 G= 1001 = 9 整除，因此能检测出单比特错误\n>\n> 上述 G 能检测任何奇数比特错误吗？为什么？\n>\n> -  奇数个 1 是不能被 (11)_2 整除的（异或运算）,例如 10101 不能被 11 整除，但是 G=1001 可以被奇数个 1 整除。\n\n# 多路访问控制（MAC）协议\n\n## 链路的两种类型：\n\n1. 点到点链路：\n\n    > 仅连接了一个发送方和一个接收方的链路。\n\n2. 广播链路：\n\n    > 连接了许多节点的**单一共享链路**，任何一个节点发送的数据可被链路上的其它节点接收到。\n\n## 多址接入（Multiple Access）\n\n- 冲突：\n\n    > 在广播链路上，若两个或多个节点同时发送，发送的信号会发生干扰，导致接收失败。\n\n- 多址接入协议：\n\n    > 规定节点共享信道（谁可以发送）的方法\n    > 多址接入协议也称媒体接入控制（Medium Access Control，MAC）协议\n\n**理想的多址接入协议：**\n\n在速率为 R bps 的广播信道上\n\n1. 当只有一个节点发送时，它应能以速率 R 发送\n\n2. 当有 M 个节点发送时，每个节点应能以 R/M 的平均速率发送\n\n3. 协议是完全分布式的:\n\n    不需要一个特殊的节点来协调发送\n    不需要时钟或时隙同步\n\n4. 简单\n\n## MAC （多址接入）协议的分类\n\n**信道划分 **\n\n- 将信道划分为若干子信道，每个节点固定分配一个子信道，不会发生冲突。\n- 包括 时分多址 TDMA，频分多址 FDMA 和 CDMA 码分多址\n\n**随机接入**\n- 不划分信道，节点可自行决定何时发送；\n- 允许出现冲突，发生冲突后设法恢复。\n\n**轮流使用信道**\n- 不划分信道，有数据要发送的节点在信道上轮流发送，不会出现冲突\n\n### 随机访问 MAC 协议\n\n随机访问 MAC 协议需要定义：\n\n- 如何检测冲突\n- 如何从冲突中恢复（e.g. 通过延迟重传）\n\n#### 时隙 ALOHA 协议\n\n假定：\n\n- 所有帧大小相同\n- 时间被划分为等长的时隙，每个时隙可以传输一个帧\n- 结点只能在时隙开始时刻发送帧\n- 节点间时钟同步\n- 如果2 个或 2 个以上结点在同一时隙发送帧，结点即检测到冲突\n\n运行：\n\n- 当结点有新的帧时，在下一个时隙发送\n\n    如果无冲突，该节点可以在下一个时隙继续发送新的帧\n\n    如果有冲突，该节点在下一个时隙以概率 p 重传该帧（1-p 不发帧），直至成功\n\n优点：\n\n- 单个节点活动时，可以连续以信道全部速率传输数据\n- 高度分散化：只需同步时隙\n- 简单\n\n缺点：\n\n- 冲突 -> 浪费时隙\n- 空闲时隙\n- 节点也许能以远小于分组传输时间检测到冲突，从而可以终止传输\n- 要求节点之间时钟同步\n\n\n\n效率：当网络中存在大量活跃节点时，长期运行过程中成功时隙所占的比例\n\n- 假设 N 个结点有很多帧等待传输，每个节点在每个时隙均以概率 p 发送数据。\n\n- 对给定**一个结点**，在一个时隙将帧发送成功的概率 $p(1-p)^{N-1}$\n\n    > 这个数据帧选择发送，其余 N-1 个结点选择不发送\n\n- 给定时隙中**有节点发送成功**的概率 = $Np(1-p)^{N-1}$\n\n    > 同时是信道空闲的比例（对那个成功发送出去的帧来说，信道是空闲的）\n\n- **最大效率**\n\n    > 1. 找到令  $Np(1-p)^{N-1}$ 最大的概率 $p^* = \\frac{1}{N}$\n    >\n    > 2. 带入$Np(1-p)^{N-1}$，并令N 趋于无穷\n    >\n    >      $lim_{N-> \\infty} (1-\\frac{1}{N})^{(N-1)} = lim_{N-> \\infty} (1+\\frac{1}{-N})^{(-N)(-1)} = \\frac{1}{e} $\n    >\n    > 3. 得到，最大效率 $E = 1/e = 0.37$\n\n- **最好的情况下，信道平均被成功利用（占所有的带宽）的时间占 37%**\n\n    **此时，成功发送一个帧需要的发送次数为 $1/E = e = 2.71828... = 2.72$**\n\n\n\n#### 纯 ALOHA 协议\n\n非时隙：更加简单，无需同步\n\n当有新的帧生成时，立即发送数据\n\n**冲突可能性增大：**\n\n  {% asset_img 3.PNG This is an pure aloha image %}\n\n**所以，纯 aloha 协议的效率肯定比 aloha 协议低。**\n\n  {% asset_img 4.PNG This is an pure aloha efficiency image %}\n\n### 载波侦听多址协议 CSMA\n\n发送前监听信道：\n\n- 信道空闲：发送整个帧\n- 信道忙：推迟发送\n\n冲突仍然有可能发生：\n\n- 存在传输延迟，所以节点可能没有监听到其他结点正在发送\n- 一旦发生冲突，整个帧的传输时间被浪费\n\n### 带冲突检测的 CSMA  –  CSMA/CD\n\n- 通过测量收到的信号强度检测冲突：\n\n    冲突信号的强度较大。\n\n    > 仅适用于有线网络，如 **以太网**\n\n- 检测到冲突之后立即停止传输损坏的帧：\n\n    减少信道浪费。\n\n- 需要满足的条件：\n\n    假设网络带宽 $R~bps$  数据帧最小长度 $L_{min}(bits)$，信号传播速度 $V(m/s)$，源到目的结点的最远距离 $d_{max}$\n\n    需满足公式：$\\frac{L_{min}}{R} = RTT_{max} = \\frac{2d_{max}}{V}$\n\n     {% asset_img 5.PNG This is an CSMA/CD image %}\n\n- **效率：**\n\n    Tprop = LAN 中两个节点间的最大传播延迟\n\n    $t_{trans}$ = 最长帧传输延迟\n\n    效率 = $1/(1+5t_{prop}/t_{trans})$\n\n    prop 趋于 0，或者 trans 趋于无穷时，效率趋于 1\n\n    > 远优于 aloha 协议，且更加简单、分散。\n\n\n\n### 轮转访问 MAC 协议\n\n综合 **信道划分 MAC 协议** 和 **随机访问 MAC 协议** 的优点：\n\n1. 数据传输过程中不会出现冲突\n2. 数据传输时利用链路的全部带宽\n\n**轮询 polling**：\n\n- 主结点轮流邀请从属结点发送数据\n- 问题：\n    1. 轮询开销\n    2. 等待延迟\n    3. 单点故障风险（如果主结点宕机，则网络瘫痪）\n\n**令牌传递 token passing**：\n\n- 控制令牌依次从一个结点传递到下一个结点\n- 令牌：特殊帧，获得令牌的结点可以发送数据\n- 问题：\n    1. 令牌开销\n    2. 等待延迟\n    3. 单点故障（令牌丢失）\n\n### MAC 协议比较\n\n**信道划分MAC协议:**\n\nTDMA / FDMA / CDMA\n\n- 重负载下高效：没有冲突，节点公平使用信道\n- 轻负载下低效：即使只有一个活跃节点也只能使用1/N的带宽\n\n**随机接入MAC协议：**\n\nALOHA / CSMA / CSMA-CD （以太网） / CSMA-CA（802.11 无线局域网）\n\n- 轻负载时高效：单个活跃节点可以使用整个信道\n- 重负载时低效：频繁发生冲突，信道使用效率低\n\n**轮流协议（试图权衡以上两者）**\n\n蓝牙、FDDI、令牌环网\n\n- 按需使用信道（避免轻负载下固定分配信道的低效）\n-  消除竞争（避免重负载下的发送冲突）\n\n# 局域网 LANs\n\n**局域网 LAN（Local Area Network）**\n\n- 将小范围内的计算机及外设连接起来的网络，范围在几公里以内\n\n**城域网 MAN（Metropolitan Area Network ）**\n\n- 通常覆盖一个城市的范围（几十公里），如有线电视网、宽带无线网等\n\n- 城域网要能支持数据、音频和视频在内的综合业务，服务质量好，支持用户数量多\n\n**广域网 WAN（Wide Area Network）**\n\n- 通常覆盖一个国家或一个洲（一百公里以上），规模和容量可任意扩大\n\n## 链路层编址（MAC 地址）和 ARP 协议\n\n每一块网络适配器（网卡）固定分配一个地址，称为 **MAC地址** ，也称物理地址、硬件地址、链路层地址、**以太网地址**、**局域网地址**等。\n\n**MAC 地址长 6 个字节**，一般用由 “ : ” 或 “ - ” 分隔的 6 个十六进制数表示：\n\n- e.g. `1A-2F-BB-76-09-AD`\n\nMAC 地址由 IEEE 负责分配，**每块适配器的地址是全球唯一的**：\n\n- 网卡生产商向 IEEE 购买一块 MAC 地址空间（前 3 字节）\n\n- 生产商确保生产的每一块网卡有不同的 MAC 地址\n\n- MAC地址固化在网卡的 ROM 中\n- **MAC 地址（链路层） == 身份证号（可携带）用于标识帧；**\n- **IP 地址（网络层） == 邮政地址，存在上下级的归属关系（不可携带）用于标识数据报；**\n\n现在用软件改变网卡的 MAC 地址也是可能的\n\n### MAC 地址类型\n\n**目的 MAC 地址**有三种类型：\n\n- 单播地址：适配器的 MAC 地址，地址最高比特为0\n\n- 多播地址：标识一个多播组的逻辑地址，地址最高比特为 1\n\n- 广播地址：`ff:ff:ff:ff:ff:ff `\n\n网络适配器仅将发送给本节点的帧（单播，广播，多播）交给主机\n\n若将适配器设置成混收模式，适配器将收到的所有帧交给主机\n\n### ARP：地址解析协议\n\n**问题：在同一个 LAN 内，如何在已知目的节点的 IP 地址前提下确定其 MAC 地址？**\n\nANS：LAN 中每个 IP 结点（主机、路由器）维护一个表 – ARP 表。\n\n- 用来存储 LAN 结点的 IP/MAC 地址的映射关系：`<IP 地址; MAC 地址;TTL>`\n\n    > TTL： time to live\n    >\n    > 经过这个时间以后该映射关系会被遗弃（典型值为 20min）\n\n\n\n**ARP 的解析（获得与 IP 地址对应的 MAC 地址）过程：**\n\n**同一个局域网里的结点：**\n\n**假设 A 想知道 B 的 MAC 地址：**\n\n- **A 构造一个 ARP 请求**，在发送方字段填入自己的 MAC 地址和 IP 地址，在目标字段填入 B 的 IP 地址。\n\n- A 将 ARP 请求封装在**广播帧**中发送\n\n    > 目的 MAC 地址（广播地址） = FF-FF-FF-FF-FF-FF\n\n- 每个收到 ARP 请求的节点**用目标 IP 地址与自己的 IP 地址比较**，地址相符的节点进行响应（B响应）。\n\n- **B 构造一个 ARP 响应**，交换发送方与目标字段内容，在发送方硬件地址字段填入自己的 MAC 地址，修改操作字段为 2\n\n- B 将 ARP 响应封装在**单播帧（目的地址为A的MAC地址）**中发送。\n\n- A 在其 ARP 表中，缓存 B 的 IP-MAC 地址对，直到超时；超时后，再次刷新。\n\n- **ARP 是 即插即用 的协议：结点自主创建 ARP 表，无需干预。**\n\n\n\n**不同局域网中的结点：**\n\n  {% asset_img 6.PNG This is an LAN-LAN image %}\n\n  {% asset_img 7.PNG This is an LAN-LAN-2 image %}\n\n\n\n## 以太网 ETHERNET\n\n以太网是第一个广泛应用的局域网技术，也是目前占主导地位的有线局域网技术。\n\n比其他局域网技术简单、成本低，且能满足网络速率需求。\n\n### 以太网：物理拓扑\n\n**总线型拓扑（共享式以太网）：**\n\n- 以同电缆作为共享传输媒体（总线）\n\n- 所有节点通过特殊接口连接到这条总线上\n- 所有节点在同一冲突域（collision domain）（可能彼此冲突）\n\n**星型拓扑**：\n\n- **基于集线器（hub）的星型拓扑（共享式以太网）：**是一个**物理层设备**，把从一个端口进入的物理信号（光，电）放大后立即从其它端口输出\n\n- **基于交换机（switch）的星型拓扑（交换式以太网）：** 是一个**链路层设备**。\n\n    > 主机通过双绞线或光纤连接到交换机；\n    >\n    > 交换机在端口之间存储－转发帧；\n    >\n    > 各节点仅与中心节点直接通信，各节点之间不直接通信，**所以每个节点和交换机之间单独冲突域，结点间彼此不冲突。**\n    >\n    > 如果没有源和目的地址之间的冲突，其总带宽为单个以太网段带宽的 N 倍，此时这些主机之间能够同时进行双工通信，而不会产生干扰。\n\n### 无连接、不可靠的传输\n\n**无连接：**\n\n- 发送帧的网卡与接收端的网卡没有握手过程。\n\n**不可靠：**\n\n- 接收网卡不向发送网卡进行确认\n\n- 差错帧直接丢弃，丢弃帧中的数据恢复依靠高层协议（如，TCP），否则，发生数据丢失。\n\n\n\n**以太网的 MAC 协议：采用二进制指数退避算法的 CSMA/CD**\n\n> 在发生冲突时，用该算法来计算下一个帧的传输等待时间。\n>\n> 算法在网卡（NIC）上实现并运行。\n\n1. NIC 从网络层接收数据包，创建数据帧\n\n2. 监听信道：\n\n    如果 NIC 监听到信道空闲，则开始发送帧；\n\n    如果监听到信道忙，则一直等待到信道空闲，然后发送帧；\n\n3. 如果 NIC 检测到其他结点传输数据，则中止发送，并发送堵塞信号 jam signal。\n\n4. 中止发送后，NIC 进入**二进制指数退避**：\n\n    第 m 次连续冲突后：\n\n    - 取 n = Max(m,10)\n\n    - NIC 从 {0，1，2，…，2^n -1} 中随机选择一个数 K\n    - **NIC 等待 K\\*512 比特的传输延迟时间**，再返回第二步\n\n\t连续冲突次数越多，平均等待时间越长。\n\n\t连续 16 次冲突之后，不再尝试，直接向上级报错。\n\n   {% asset_img 8.PNG This is an ethernet image %}\n\n## 以太网交换机\n\n**链路层设备：**\n\n- 存储-转发以太网帧\n- 检验到达帧的目的 MAC 地址，**选择性**向一个或多个输出链路转发帧\n- 利用 CSMA/CD 访问链路，发送帧\n\n**透明：**\n\n- 主机感知不到交换机的存在\n\n**即插即用：**\n\n- 直接接入网络，通过自学习就可以使用。\n\n**自学习：**\n\n- 交换机无需配置\n\n### 端口转发表\n\n   {% asset_img 9.PNG This is an switch image %}\n\n   {% asset_img 10.PNG This is an switch-selflearning image %}\n\n### 帧的过滤和转发\n\n   {% asset_img 11.PNG This is an switch-selflearning-2 image %}\n\n**交换机收到帧的处理过程：**\n\n> **用帧的目的地址查找转发表（转发决策）：**\n>\n> 若目的地址所在端口 = 帧的进入端口，丢弃帧\n>\n> 若目的地址所在端口 ≠ 帧的进入端口，转发帧\n>\n> 若目的地址不在转发表中，扩散帧\n>\n> **用帧的源地址查找转发表（更新转发表）：**\n>\n> 若找到地址，将对应表项的生存期设为最大值\n>\n> 若没有找到该地址，添加源地址和进入端口到转发表，设置表项的生存期为最大值\n\n### 交换机互联\n\n   {% asset_img 12.PNG This is an switch-selflearning-3 image %}\n\n\n\n## 交换机 VS 路由器\n\n1. 两者均为存储-转发设备：\n\n    交换机：链路层设备，检测网络分组首部，转发速度快，成本低（二层设备）\n\n    路由器：网络层设备，检测链路层帧首部，转发速度慢，成本高（三层设备）\n\n2. 二者均使用转发表：\n\n    交换机：利用自学习、泛洪构建转发表，依据  MAC 地址\n\n    路由器：利用路由算法（路由协议）计算，依据 IP 地址\n\n\n\n# 虚拟局域网 VLAN\n\n**基本概念：**\n\n支持 VLAN 划分的交换机，在一个物理局域网上，配置、定义多个 VLAN。\n\n每个 VLAN 在逻辑上是一个独立的 IP 子网：\n\n- 每个 VLAN 是一个单独的广播域，一个 VLAN 中的所有帧流量被限制在该 VLAN 中\n- 不同VLAN之间的通信要依赖于网络层路由\n\n   {% asset_img 13.PNG This is an VLAN image %}\n\n\n\n**如何知道一个帧属于哪个 VLAN？**\n\n根据帧的到达端口、源 MAC 地址或源 IP 地址（由VLAN的划分方法确定），查找 VLAN的配置表获悉\n\n为避免重复查找 VLAN配置表，帧头中携带其所属的VLAN标识\n\n后续交换机通过检查帧头的VLAN标识得知这个帧所属的VLAN\n\n> 802.1Q 规定了新的以太帧格式，帧头中包含一个 VLAN 标签（tag），用于指明帧属于哪个 VLAN。\n\n\n\n**三层交换机和路由器：**\n\n不同子网或 VLAN 之间通过路由器转发，太慢！太贵！\n\n三层交换机：\n\n- 具有部分路由功能、又有二层转发速度的交换机\n\n- 专为加快大型局域网内部的数据交换而设计\n\n- 但在安全、协议支持等方面不如专业路由器\n\n三层交换机的使用：\n\n通常用在机构网络的核心层，连接不同的子网或 VLAN\n\n专业路由器：连接机构网络与外网\n\n# PPP 协议\n\n**点对点数据链路控制**：一个发送端，一个接收端，一条链路：比广播链路容易。\n\n**PPP** 是因特网中广泛使用的点到点数据链路协议，用于 PC 机到因特网的拨号连接，以及路由器到路由器之间的专线连接。\n\n**PPP 由以下三部分组成：**\n\n1. 一种在串行通信线路上的**组帧**方式，用于区分帧的边界，并**支持差错检测**。\n2. 一个用于**建立、配置、测试和拆除**数据链路的链路控制协议 LCP。\n3. 一组网络控制协议（NCP），用以**支持不同的网络层协议**。\n\n**PPP 无需支持的功能：**\n\n1. 无需差错纠正、恢复（一般由高层协议处理）\n2. 无需流量控制\n3. 不存在乱序交付\n4. 无需支持多点链路\n\n**PPP 数据帧：**\n\n   {% asset_img 14.PNG This is an VLAN image %}","tags":["计算机网络"],"categories":["复习笔记"]},{"title":"MySQL - 关系模型","url":"/2021/02/05/mysql-RelationalModel/","content":"\n\n关系模型本质上是若干个存储数据的二维表。\n\n表的每一行称为 **记录（Record）**，每一列称为 **字段（Column）**。\n\n字段定义了数据类型（整型、浮点型、字符串、日期等），以及是否允许为 NULL（表示字段数据不存在）。\n\n关系数据库中，关系是通过 **主键** 和 **外键** 来维护的。\n\n<!--more-->\n\n**RDBMS（关系数据库管理系统）的特点：**\n\n1. 数据以表格形式出现\n2. 每行为一条记录\n3. 每列为字段名称对应的数据域（每列数据类型相同）\n4. 行和列组成表单（数据矩阵）\n5. 若干表单组成 database\n\n## 主键\n\n关系表中的每一条记录都包含若干字段。同一个表的所有记录都有相同的字段定义。\n\n关系表的约束：表中任意两条记录不能重复。\n\n> 不能重复不代表不存在两条完全相同的记录，而是指当两条记录不同时，要能通过**某个字段 唯一**区分出他们。\n\n主键用来唯一定位记录，故而在记录插入表中之后，不能轻易修改。\n\n选取主键的**基本原则**：不使用任何业务相关的字段作为主键（最大程度上避免主键修改的可能性），当然也不能是 NULL。\n\n主键字段一般命名为 id，常见可作为 id 的字段类型：\n\n1. 自增整数类型：数据库会在插入数据时自动为每个记录分配一个自增整数。\n2. 全局 GUID 类型：使用一种全局唯一的字符串作为主键。类似`8f55d96b-8acc-4636-8cb8-76bf8abc2f57`。GUID算法通过网卡MAC地址、时间戳和随机数保证任意计算机在任意时间生成的字符串都是不同的，大部分编程语言都内置了GUID算法，可以自己预算出主键。\n\n> 对于大部分应用来说，通常自增类型的主键就能满足需求。\n>\n> BIGINT 自增类型最多可以记录 922亿亿条记录。\n\n\n\n## 联合主键\n\n顾名思义，联合主键就是用多个字段来唯一标识记录，这些字段共同组成主键，就叫联合主键。\n\n对于联合主键，允许有一列重复，只要不是所有主键列都重复即可。\n\n> 说白了就是互相帮助。你不行了我上，但是不能都不行。\n\n联合主键的存在会提高关系表的复杂度，所以不常用。\n\n\n\n## 外键\n\n### 从 一对多 引入\n\n一个班级对应多个学生，是典型的 “一对多” 关系。即一个`classes`的记录可以对应多个`students`表的记录。\n\n为了表达这种一对多的关系，我们需要在`students`表中加入一列`class_id`，让它的值与`classes`表的某条记录相对应。\n\n这样，我们就可以根据`class_id`这个列直接定位出一个`students`表的记录应该对应到`classes`的哪条记录。\n\n在`students`表中，通过`class_id`的字段，可以把数据与另一张表关联起来，这种列称为 **外键**。\n\n外键在数据库中的两种表现形式：\n\n1. 名副其实的外键：\n\n    定义了外键约束\n\n    ```sql\n    ALTER TABLE students\n    ADD CONSTRAINT fk_class_id\n    FOREIGN KEY (class_id)\n    REFERENCES classes (id);\n    ```\n\n    - 外键约束的名称 `fk_class_id` 可以任意。\n    - `FOREIGN KEY (class_id)` 指定了 `class_id` 作为外键。\n    - `REFERENCES classes (id)` 指定了这个外键将关联到 `classes` 表的 `id` 列（即 `classes` 表的主键）。\n\n    删除外键约束，通过 `ALTER TABLE实现`：\n\n    ```sql\n    ALTER TABLE students\n    DROP FOREIGN KEY fk_class_id;\n    ```\n\n    这里没有删除外键这一列，只是删除约束而已。删除列是通过`DROP COLUMN ...`实现的。\n\n2. 逻辑上的外键：\n\n    外键约束会降低数据库的性能，所以为了追求速度，不设置外键约束，而仅靠应用程序自身来保证逻辑的正确性。\n\n    这时 （1）中的 `class_id` 就只是普通的列，而只是在逻辑意义上起到了外键的作用而已。\n\n### 多对多\n\n多对多关系实例：一个老师对应多个班级，一个班级也可以对应多个老师。因此班级和老师之间存在多对多关系。\n\n多对多关系是通过两个一对多关系实现的：有一个中间表，关联两个一对多关系。\n\n### 一对一\n\n一对一关系：一个表的记录对应到另一个表的唯一一个记录。\n\n这样的表可以根据外键合并也可以拆分。\n\n\n\n> 综上，关系数据库通过外键可以实现一对多，多对多和一对一的关系。外键既可以通过数据库来约束，也可以不设置约束，仅靠应用陈旭的逻辑实现。\n\n\n\n## 索引\n\n在关系数据库中存有多条记录，为了快速的找到某条记录，我们使用索引。\n\n**索引**：关系数据库中对某一列或多个列的值进行预排序的数据结构。可在查找记录时直接定位到符合条件的记录，大大加快查询速度。\n\n例如，对 `students` 表：\n\n- id 学号\n- class_id 班级\n- name 姓名\n- gender 性别\n- score 成绩\n\n如果要经常根据`score`列进行查询，就可以对`score`列创建索引：\n\n```sql\nALTER TABLE students\nADD INDEX idx_score (score);\n```\n\n使用`ADD INDEX idx_score (score)`就创建了一个名称为`idx_score`，使用列`score`的索引。\n\n索引名称是任意的，索引如果有多列，可以在括号里依次写上，例如：\n\n```sql\nALTER TABLE students\nADD INDEX idx_name_score (name, score);\n```\n\n**索引的效率取决于索引列的值是否散列，对于主键，因为主键保证绝对唯一，所以使用主键索引效率最高。**\n\n**关系数据库会自动对其创建主键索引。**\n\n> 虽然索引提高了查询效率，但是在插入、更新和删除记录使，需要同时修改索引。故而索引越多，插入等操作的速度就会更慢。\n\n### 唯一索引\n\n根据业务要求，具有唯一性约束的列（例如身份证号码）可以添加唯一索引，**从而保证这一列的值具有唯一性**。例如学生的身份证号不能重复：\n\n```sql\nALTER TABLE students\nADD UNIQUE INDEX uni_pid (pid);\n```\n\n> 通过 unique 关键字添加唯一索引\n\n也可以只添加唯一约束不创建唯一索引：\n\n```sql\nALTER TABLE students\nADD CONSTRAINT uni_pid UNIQUE (pid);\n```\n\n添加索引只不过是让数据库的查询锦上添花，没有索引数据库当然也能正常运行，因此索引可以在使用数据库的过程中逐步优化。\n\n","tags":["mysql"],"categories":["教程类"]},{"title":"MySQL 安装教程 + 排坑","url":"/2021/01/27/mysql-install/","content":"**本教程基于 windows10(64位) 操作系统**\n<!--more-->\n# 下载\n\n1. 访问 [官网下载地址](https://dev.mysql.com/downloads/mysql/)\n   {% asset_img 1.PNG This is an download image %}\n\n2. 点击 `No thanks,just start my download` 跳过注册过程，直接下载压缩包。\n\n\n# 安装与配置\n\n- 在指定路径解压，将解压后 bin 文件的路径（`D:\\mysql-8.0.23-winx64\\bin`）添加到系统环境变量中：\n  > 我的电脑->属性->高级->环境变量\n  > 选择PATH,在其后面添加: 你的 mysql bin 文件夹的路径\n- 使用管理员身份打开 cmd：\n  > 在开始菜单中输入 cmd，选择用管理员身份打开；\n- 跳转到 mysql bin 目录下：\n  {% asset_img 2.PNG This is an bin path %}\n- 安装 mysql\n  ```\n  mysqld -install\n  ```\n- 初始化 mysql（一定要初始化！否则容易导致启动不成功）\n  ```\n  mysqld --initialize\n  ```\n- 启动服务\n  ```\n  net start mysql\n  ```\n  {% asset_img 3.PNG This is an start successfully image %}\n\n  > 这里直接写 mysql 是因为我主机服务中 mysql 的服务名就是 mysql，如果大家出现了启动不成功的情况可以自行搜索是不是服务名不同。\n\n- 登录 mysql：\n  ```\n  mysql -u root -p\n  ```\n  据说第一次登录不需要密码，直接按回车就好了，但是博主按了回车发现不行。出现报错 `ERROR 1045 (28000): Access denied for user 'root'@'localhost' (using password: NO)`\n  {% asset_img 4.PNG This is an start failed image %}\n  看来还是需要我们输入密码，下面一起找密码吧：\n  1. 打开 mysql 的根目录下名为 data 的文件夹；\n  2. 找到以 `.err` 为结尾的文件（专门记录报错信息的）并打开；\n  3. 找到自动生成的密码啦！\n   {% asset_img 5.PNG This is an password image %}\n  4. 输入密码即可~\n   {% asset_img 6.PNG This is an load successfully image %}\n\n# 通过 vscode 连接 mysql\n\n旨在利用 vscode 能更加便捷的编写并执行 SQL 代码。\n\n参考文章：[MySQL vscode开发环境搭建](https://zhuanlan.zhihu.com/p/347159257)\n\n## 基础知识\n\n> MySQL 相当于一个 shell，SQL 就是和 shell 交互的脚本语言。\n> 众所周知，与 shell 打交道的方式有两种：\n> - 一种是直接在shell中输命令执行，但是这样很难让我们看到多条shell的作用。\n> - 还有一种方式是编写 shell 脚本。在 bash 中，shell 脚本的文件名后缀可以是 .sh，在 MySQL 中，脚本的后缀名为 .sql\n\n## 安装插件\n\n1. 打开 vscode 插件商店；\n2. 搜索并安装如下两个插件：\n   - MySQL [by Jun Han]\n   - MySQL Syntax [by Jake Bathman]\n3. 以管理员身份打开 cmd；\n4. `net start mysql` 启动服务；\n5. `mysql -u root -p` 进入 MySQL 账户（密码的查找方式见上）\n6. 进入 mysql 的 shell 之后，输入命令：\n   ```\n    alter user 'root'@'localhost' identified with mysql_native_password by '123456';\n   ```\n   重置密码为 `123456`\n\n## vscode 连接本机数据库\n\n1. 打开 vscode ，点击左下角的 MYSQL 旁边的加号：\n   {% asset_img 7.PNG This is an load successfully image %}\n\n2. 在弹出的对话框中设置参数：\n   - host: 127.0.0.1\n   - username: root\n   - password: 123456 (刚设置的)\n   - 其他参数保持默认，一路回车下去\n\n## 一个栗子\n\n1. 在 MYSQL 下方的蓝色饼饼图标处右键，选择 new_query\n2. 在弹出的编辑栏中输入 SQL 指令，并以 `.sql` 为后缀名保存到本地\n3. 编辑区右键，选择 Run MySQL query\n4. 你会在编辑区右侧看到指令的执行结果。\n\n## 震惊！vscode 的 mysql 插件不支持过程化 sql 语句\n\n太悲惨了，博主爆哭 wwwww\n为了不放弃自己辛辛苦苦搞的 vscode ，博主进行了多方尝试，最终还是不行 wwwwwww\n大家转战 mysql workbench 吧（官网下载安装）\n\n\n","tags":["mysql"],"categories":["教程类"]},{"title":"hexo+stun 博客搭建","url":"/2021/01/26/hexo-stun/","content":"\n# 背景\n\n看到某位同学搭了自己的博客，觉得有一个记录自己成长路线的博客好像挺香的…刚好寒假时间比较充裕，是个动手的好时机~\n\nGithub Pages 功能 +  Hexo 的博客框架 + 自己喜欢的主题 = 华而有实的博客\n\n<!--more-->\n\n使用 Github Pages 搭建博客的好处：\n\n1. 免费，免费，免费！\n2. 都是静态文件，访问速度较优；\n3. 能和 git 搭配使用，管理起来都是熟悉的配方；\n\n使用 hexo 的好处：\n\n1. 简洁高效，安装简单；\n2. 有多种稳定、美观的主题可以挑选；\n3. 使用 Markdown 解析文章，符合自己平时写东西的习惯；\n\n> 当然其他框架也有各自的优点，这个选择凭各自喜好啦~\n\n**本教程以 windows 为例**\n\n\n# Github Pages\n\n**基于 [Github Pages 官方文档](https://docs.github.com/cn/github/working-with-github-pages/creating-a-github-pages-site)**\n\n前提是要有 github 账号，没有的同学们可以先去注册一个~\n\n1. 创建 Github Pages 站点：\n\n    - 新建一个仓库；\n    - 输入仓库的名称和说明（可选）。 如果您创建的是用户或组织站点，仓库名称**必须为** `<user>.github.io` 或 `<organization>.github.io` ；\n    - 设置仓库属性为 `public` ;\n    - 选择 `Initialize this repository with a README`（使用 readme 文件初始化此仓库；\n    - `create repository`\n\n2. 设置站点：\n\n    - 在站点仓库下，找到右上角 `Settings`\n\n    - 下滑，找到`Github Pages`选项卡，你能看到站点的 url 啦~\n        {% asset_img 1-1.jpg This is an github-pages image %}\n        > 这个 url 就是你网站的地址，通过它，大家就能访问到你的博客。\n\n    - Source 栏的 branch 选择 main（或者 master，总之就是除了 none 之外的那个），点击 save；\n\n    - Theme Chooser 那个不用管，因为后续要使用 hexo 的主题嘛；\n\n    - 将仓库克隆到本地，用 git 配置自己的身份信息：\n\n        ```\n        git config --global user.name \"github user name\"\n        git config --global user.email \"github user email\"\n        ```\n\n    - [添加 ssh-key](https://www.liaoxuefeng.com/wiki/896043488029600/896954117292416)（注意不要设置密码）主要是为了以后 hexo 发布比较方便。\n\n\n\n# hexo\n\n**基于 [hexo](https://hexo.io/zh-cn/docs/) 官方文档**\n\n## 安装\n\n安装 hexo 之前，先来把环境搞好：\n\n- 安装 [Node.js](http://nodejs.org/) (Node.js 版本需不低于 10.13，建议使用 Node.js 12.0 及以上版本)\n- 安装 Git （ 不过 github 那一步都搞好了，这里就不用了吧~）\n\n> 这里具体的安装细节提示可以直接参考各自官方文档，或者网上找找教程。\n\n现在可以安装 hexo。\n\n在合适的地方新建一个文件夹，用来存放自己的博客文件，比如我的博客文件都存放在`D:/blog`目录下。\n\n我使用 Windows 自带的控制台定位到`D:/blog`目录下执行以下操作：\n\n```\n$npm install -g hexo-cli\n```\n\n> 据说 linux 和 max 里是要在前面加个 sudo，不然会因为权限问题报错。\n\n装完输入 `hexo --version` 检查是否安装成功。\n\n## 建站\n\n`hexo init` 初始化文件夹；\n\n`npm install` 安装必须的插件；\n\n`hexo g` 生成静态文件；\n\n`hexo s` 将静态文件运行在本地服务器上，这个时候根据提示打开 `localhost:4000` 就能看到最基本的博客啦~\n\n`ctrl+c` 关闭本地服务器；\n\n## 与 github 连接\n\n打开 blog 根目录下的 `_config.yml` 文件，修改配置：\n\n```yml\n# URL\n## If your site is put in a subdirectory, set url as 'http://example.com/child' and root as '/child/'\nurl: https://github.com/xxx/xxx.github.io/\nroot: /xxx.github.io/\npermalink: :year/:month/:day/:title/\npermalink_defaults:\npretty_urls:\n  trailing_index: true # Set to false to remove trailing 'index.html' from permalinks\n  trailing_html: true # Set to false to remove trailing '.html' from\n\n...\n\n# Deployment\n## Docs: https://hexo.io/docs/one-command-deployment\ndeploy:\n  type: git\n  repo: git@github.com:xxx/xxx.github.io.git\n  branch: main\n```\n\n还是在 blog 根目录下：\n\n```c\nhexo g // 编译生成静态文件（每次修改完都必须重新编译）\nhexo d // 将博客发布到 github 上\n```\n\n现在可以通过 `https://xxx.github.io` 来访问你的博客啦~\n\n\n\n# 主题 - stun\n\n博主选的是 stun 这个主题，主要是看中了她 ~~可甜可盐~~  活泼大方、简洁美观 的风格，当然她不是最简洁的，最简洁的应该是 Next 这个主题了吧（\n\n这个官方文档超级全的！！！而且步骤都很详细！！！\n\n我在这里就不瞎写了，反正写的没有官网好，照着来没错的，嗯！\n\n官网指路：[stun](https://theme-stun.github.io/docs/zh-CN/guide/quick-start.html#%E5%AE%89%E8%A3%85)\n\n\nemmmm\n\n那我写点推荐和排雷：\n\n## 统计与分析推荐\n\n首推 [谷歌分析](https://theme-stun.github.io/docs/zh-CN/advanced/third-part.html#%E8%B0%B7%E6%AD%8C%E5%88%86%E6%9E%90) ！！！ 简单好用不要钱！！！\n\n来一篇好用的配置教程：[Google Analytics怎么用，谷歌分析工具使用教程](https://www.yundianseo.com/how-to-use-google-analytics/)\n\n\n\n## 评论系统推荐\n\n博主尝试了三种评论系统，各自利弊写在下面奥：\n\n1. Disqus\n\n    优点：\n\n    - 配置简单（所以博主最先选的就是这个）\n    - 完善的后台管理机制\n    - 丰富的表情可选\n    - 支持 markdown\n\n    缺点：\n\n    - 服务器在国外，不翻墙加载不出来\n\n    - 存在广告植入\n\n    - 要评论必须有 disqus  / google / Twitter/ facebook 账户\n\n\n\n2. Valine\n\n    优点：\n\n    - 配置简单（但没有 disqus 简单）\n    - 无后端，所以加载起来很快\n    - 页面设计简洁\n    - 评论不用登陆任何账户\n    - 支持 markdown\n\n    缺点：\n\n    - 页面设计过于简洁（我试验过之后才发现，是真的很简洁，白白的，也没有点赞的功能，想要拥有一个头像都要花挺多功夫\n    - 评论可以匿名（某同学说可能会有恶意评论，博主觉得他说的有道理…\n\n\n\n3. Utterances\n\n    优点：\n\n    - 配置看上去复杂但其实很简单：\n\n        将 [utterances app (opens new window)](https://github.com/apps/utterances)安装在你博客对应的 Github 仓库中。然后，按照 stun 官网的提示修改配置项即可；\n\n    - 是一个基于 github issues 的评论系统，管理方便；\n\n    - 支持 emoji 支持评论点赞\n\n    - 支持 markdown\n\n    缺点：\n\n    - 需要登录 github 账户才能评论（是缺点也是优点吧）\n\n## bug 分享\n\n### multiline key\n\n```\n message: 'can not read a block mapping entry; a multiline key may not be an implicit key at line 7, column 9:\\n'\n \"    subtitle: 'If you shed tears when you mi ... \\n\" +\n```\n\n网上大部分说是在对应位置缺了英文空格，但我不是这个错…\n\n这里要注意，错误可能不在这一行，可能出现在它前一行：\n\n```yml\ntitle: 'Karin Lv's Blog'\nsubtitle: 'If you shed tears...\n```\n\n我就是出现在它上一行的，这里单引号中间还有一个单引号，不符合语法规则了，所以报错…\n\n去掉外层的单引号就好了！\n\n### invalid characters\n\n出现非法字符，大概率是因为在配置文件里写了中文，但没有相应的设置。\n\n博主的做法比较简单粗暴：配置文件里尽量不写中文，都改成英文 QAQ\n\n> 大家可以在网上搜一下更专业的解决办法，不要学这个懒博主（\n\n","tags":["博客搭建"],"categories":["教程类"]},{"title":"计算机网络复习 - 网络层","url":"/2021/01/26/ComputerNetworkReview-Chap4/","content":"\n旨在理解网络层服务原理和熟悉因特网的网络层协议。\n<!--more-->\n\n# 综述\n\n通过学习这一章节，我们需要了解以下两方面内容：\n\n理解网络层服务原理：\n- 网络层服务模型\n- 网络层上的重要功能：转发和选路\n- 路由器工作原理\n- 选路算法\n\n因特网的网络层协议：\n- IP 协议\n- ICMP 协议\n- 选路协议：RIP,OSPF,BGP\n\n#  概念简介\n\n1. 网络层的**作用**：将报文段从**发送主机**传送到**接收主机**。\n\n> 每一台主机和路由器都运行网络层协议。\n>\n> 路由器：将分组从输入链路转发到输出链路。它运行的协议包括，网络层，链路层，物理层。\n>\n> 发送主机：将传输层报文段封装到网络层分组中，发送给边缘路由器。\n>\n> 接收主机：从边缘路由器接收分组，取出报文段交付给传输层。\n\n2. 网络层的主要功能：\n\n    选路：确定分组从源路由器到目的路由器的路径 – 利用各种**路由算法**来计算转发表。\n\n    转发：将分组从输入端口转移到合适的输出端口 – 根据转发表转运分组。\n\n    > 在传输分组之前，两个端系统需要建立连接。\n    >\n    > - 传输层连接：进程-进程，连接状态仅仅保存在端系统中，传输层服务在网络边缘实现\n    > - 网络层连接：主机-主机，连接状态保存在源主机，目的主机以及所有中间路由器上（路由器要保存转发表的嘛），网络层服务在网络核心实现。\n\n3. 网络服务模型\n\n    定义分组在发送主机与接收主机之间传输时的特性。\n\n    - 对单个分组提供的服务\n\n        >  保证交付；具有时延上界的保证交付；\n\n    - 对分组流提供的服务\n\n        > 有序交付；保证最小带宽；\n        > 保证最大时延抖动（分组端到端时延的最大差异）；\n\n        不同架构的网络提供的网络层服务可能不同，同一个网络也可以提供不同的网络层服务。\n\n# 虚电路和数据报网络\n\n两种基本的网络类型：\n\n**数据报网络**：提供网络层**无连接**服务\n\n**虚电路网络**：提供网络层**面向连接**服务\n\n## 虚电路 Virtual circuits\n\n网络层连接成为虚电路。\n\n虚电路是从源主机到目的主机的一条路径，类似电话电路，每条虚电路有唯一标识（虚电路号），每个分组应该携带虚电路号，表明所属的虚电路。\n\n> 传输**分组前建立虚电路**，传输结束后拆除虚电路;\n>\n> 每个路由器为经过它的虚电路维护状态（转发表项 - 进入端口，进入VC号，输出端口，输出VC号），分组携带 VC 号，每一次转发前用新的 VC 号替换分组中的 VC 号 ;\n>\n> 链路及路由器资源（带宽、缓存等）可以分配给虚电路，从而虚电路能提供**可预期的**网络服务。\n\n**信令协议：**用于 VC  的建立、维护与拆除。\n\n## 数据报网络\n\n- 分组携带目的主机地址，路由器按目的地址转发分组；\n\n- 路由器根据分组的目的地址转发分组，转发表记录目的地址到输出链路的映射；\n\n    > 实际上是存储**目的地址的范围**到**链路**的映射；\n    >\n    > 匹配规则：最长前缀匹配优先；\n\n- 转发表被选路模块修改，约1～5分钟更新一次；\n\n- 同一对主机之间传输的分组可能走不同的路径，从而可能重排序；\n\n## 数据报网络 VS 虚电路网络\n\n数据报网络：\n\n- 计算机之间交换数据：没有严格的时序要求；\n- 终端具有智能：将复杂的工作（如差错控制）推到网络边缘，以保持网络简单。\n\n虚电路网络：\n\n- 由电信网发展而来：严格时序和可靠性要求；\n- 终端无智能或很少智能：复杂工作由网络完成，以保持终端简单。\n\n\n\n# Internet 网络层协议\n\n## internet 网络层\n\n  {% asset_img 1.PNG This is an internet image %}\n\n## IPv4 数据报格式\n\n  {% asset_img 2.PNG This is an IP4 image %}\n\n## IP 数据报分片\n\n### 最大传输单元 MTU\n\nMTU：链路层数据帧可封装数据的上限；$MTU = MAX(data)$\n\n> 不同链路的 MTU 不同\n\n### 分组与重组\n\n大 IP 向比较小的 MTU 链路转发时，可以被分片 （fragmented）。\n\n1. 大 IP 分片成若干小 IP\n2. IP 分片在到达 **目的主机** 后重组（路由器只管分不管组装）\n\nIP 首部相关字段用于标识分片以及确定分片的顺序（便于在目的主机重组 IP 分组）\n\n> 涉及到的字段：总长度、标识、标志和片偏移字段。\n\n- 标识：每个分片必须携带与原始数据报相同的标识。\n- 标志位：\n    - MF（more fragments）：最后一个分片的MF=0，其余分片的 MF=1\n    - DF（don’t fragment）：DF=1 表示不允许对数据报分片\n- 片偏移量（13bits）：指示分片中的数据在原始数据报载荷中的位置（以 8 字节为单位）\n\n**分片的处理过程**\n\n根据报头长度 H 和输出线路的 MTU 为 M，原 IP 分组的总长度为 L 。\n\n一个最大分片可封装的数据为：$d = \\lfloor \\frac{M-20}{8} \\rfloor * 8 ~ Bytes$\n\n需要的总片数为： $n = \\lceil \\frac{L-20}{d} \\rceil$\n\n1. 将数据报的载荷划分成长度为 d 的若干片段（最后一个分片可能不足 d 字节）。\n\n2. 将原始报头加到每一个分片的前面，修改报头中的以下字段：\n\n    $\\text{总长度} = d + 20,  ~(1 <= i < n)$;   $ or = L-(n-1)d, ~(i = n)$\n\n    最后一个报头的 MF 位置 0，其余报头的 MF 位置 1\n\n    偏移量：$F_i = \\frac{d}{8} * (i-1), ~~~ 1\\le i \\le n$\n\n4. 计算头部检查和\n\n## IP 编址\n\n**接口：** 主机 or 路由器 与物理链路的边界。\n\n**IP 地址：**32bit 标识主机、路由器的接口。一般采用点分十进制标识（8位一组，转成十进制），例如：`127.0.0.1`\n\n**如何为接口分配 IP 地址？**\n\n-  IP 地址分为两部分，高位比特为网络号，低位比特为主机号。\n- **IP 子网：** IP 地址具有相同的网络号，**不跨越路由器**，可以彼此物理联通的接口。\n\n### 有类编址\n\n  {% asset_img 3.PNG This is an IP class image %}\n\n\n\nA,B,C 类 IP 地址可以用来给主机或路由器分配网络接口，但也有一些特殊情况。\n\n\n\n {% asset_img 4.PNG This is an IP special image %}\n\n### 子网划分\n\nIP 地址：\n\n- 网络号 NetID - 高位比特\n- 子网号 SubID - 原网络主机号部分比特\n- 主机号 HostID - 低位比特\n\n**如何确定是否划分了子网？利用多少位划分子网？**\n\n- **子网掩码**：形如 IP 地址。**取值：NetID、SubID 全部取 1， HostID 全部取 0**\n\n    > 例如：\n    >\n    > A 网默认子网掩码 ：`255.0.0.0`\n    >\n    > B 网默认子网掩码 ：`255.255.0.0`\n    >\n    > C 网默认子网掩码 ：`255.255.255.0`\n    >\n    > 借用 3 比特划分子网的 B 网的子网掩码：`255.255.224.0`\n\n- 对特定主机来说，前 32 位都看成网络号，即其子网掩码为 `255.255.255.255`\n\n- 子网地址 + 子网掩码 = 准确确定子网大小\n\n    > 例：将 子网 `201.2.3.0`, `255.255.255.0` 划分为等长的 4 个子网。\n    >\n    > 分析：\n    >\n    > C 网，主机号范围只有最后 8 位（一共可以有 256 个不同的主机号）\n    >\n    > $256 / 4 = 64$，所以将最后 8 位的前两位借为子网号，划分的四个子网如下：\n    >\n    > 1. `201.2.3.0    子网号(00)   255.255.255.192`\n    >\n    >     该子网的 IP 地址范围为 `201.2.3.0 ~ 201.2.3.63`\n    >\n    >     去掉子网 IP 地址(0)和该子网的广播地址(63)，**可分配的 IP 地址**为：`201.2.3.1 ~ 201.2.3.62`\n    >\n    > 2. `201.2.3.64   子网号(01)   255.255.255.192`\n    >\n    > 3. `201.2.3.128  子网号(10)   255.255.255.192`\n    >\n    > 4. `201.2.3.192  子网号(11)   255.255.255.192`\n\n#### 一个栗子\n\n{% asset_img 11.PNG This is an eg image %}\n\n> 其中 `0.0.0.0` 是一个特殊 IP ，表示所有待选 IP 都没有匹配到，这个特殊 IP 没有网络号。\n\n{% asset_img 12.PNG This is an eg-3 image %}\n\n\n\n### 无类域间路由 CIDR\n\nCIDR (Classless InterDomain Routing)：\n\n- 消除传统的 A、B、C 类地址界限：$NetID + SubID->Network~Prefix$\n\n- 融合子网地址与子网掩码，方便子网划分：`a.b.c.d/x` 其中 x 为前缀长度\n\n    > 例如：`200.23.16.0/23`\n    >\n    > C 类地址前 24 位都是网络号，但这里的 CIDR 地址的前缀只有 23 位。\n    >\n    > 实际上它是两个 C 类地址的组合：`200.23.16.0` 和 `200.23.17.0` (第24位分别为 0 和 1)\n\n- 子网 `201.2.2.3.64  255.255.255.192 -> 201.2.3.64/26`\n\n**优点**：\n\n- 提高 IPv4 地址空间分配效率\n\n- 提高路由效率\n    1. 将多个子网聚合为一个较大的子网\n    2. 构造超网（supernetting）\n    3. 路由聚合（route aggregation）\n\n#### 路由聚合\n\n路由表中符合聚合条件的若干条路由可以**合并成一条路由**：\n\n- 这些路由的前缀可以聚合成一个更短的前缀（称地址前缀）\n- 这些路由使用相同的下一跳\n- 路由聚合的过程可以递归进行\n\n  {% asset_img 5.PNG This is an CIDR image %}\n\n\n\n> 若个别路由不满足路由聚合的条件，可以给出一条聚合路由和若干条特定路由。\n>\n> **最长前缀匹配优先**：在所有匹配的路由表项中，选择前缀最长的路由表项。（避免路由黑洞现象【数据到达不了目标地址】）\n>\n>  {% asset_img 6.PNG This is an special CIDR image %}\n\n\n\n##  DHCP 协议\n\n**一个主机如何获得 IP 地址？**\n\n- 硬编码：静态配置（手动）\n\n    > 默认网关：数据报离开子网时，将要经过的路由器接口。数据报将通过这个路由器进一步转发到其他路径。\n\n- 动态主机配置协议 DHCP：自动获取（租赁）IP 地址、子网掩码、默认网关地址、缺省路由器、本地 DNS 服务器等配置信息。\n\n    > 即插即用；\n    >\n    > 允许地址重用（IP 地址采用租赁的形式，当一个主机不用时，归还 IP ，这个 IP 就可以分给其他主机使用）；\n    >\n    > 可以续租；\n\n**DHCP 工作过程：**\n\n- 主机**广播** “DHCP discover” 报文\n\n    > 寻找子网中的 DHCP 服务器\n\n- DHCP 服务器用 “DHCP offer” 报文进行**广播**响应\n\n    > 给出推荐的 IP 地址及租期、其它配置信息\n\n- 主机用 “DHCP request” 报文**广播**请求 IP 地址\n\n    > 主机选择一个 DHCP 服务器，向其请求 IP 地址\n\n- DHCP 服务器用“DHCP ack” 报文发送IP地址\n\n    > 响应客户的请求，确认所要求的参数\n\n- DHCP 服务器使用 UDP 端口 67，客户使用 UDP 端口 68\n\n**DHCP 的实现：**\n\n- 在应用层实现\n\n- 请求报文封装到 UDP 数据报中\n\n    > 封装 ：DHCP 应用层 -> UDP 传输层 -> IP 网络层-> Eth 链路层 -> Phy 物理层\n\n- IP 广播 -> 链路层广播（e.g. 以太网广播）\n\n## 网络地址转换 NAT\n\n**动机：**\n\n- IP地址支持许多用户同时上网\n- 仅为公共可访问的节点分配公用IP地址（减少需要的公用IP地址数）\n- 网络内部节点对外是不可见的（安全考虑）\n\n**NAT 实现：**\n\n- **外出的数据报**:  将数据报中的（源IP地址，源端口号）替换为（NAT IP地址，新端口号）\n- **NAT 转换表**：记录每个（源IP地址，源端口号）与（NAT IP地址，新端口号）的转换关系\n- **进入的数据报**: 取出数据报中的（目的IP地址，目的端口号）查找NAT转换表，然后用转换表中对应的（IP地址，端口号）进行替换\n\n**16比特端口号**:\n\n允许一个 NAT IP 地址同时支持65535个对外连接\n\n**NAT的使用有争议**:\n\n- 路由器应当只处理三层以下的报头（端口号在传输层）\n\n- 违反端到端原则（节点介入修改IP地址和端口号）\n\n    NAT 妨碍 P2P 应用程序：需要 NAT 穿越技术\n\n    > 方案一：静态配置 NAT ，将特定端口的连接请求转发给服务器。\n    >\n    > 方案二：利用 UPnP 互联网网关设备协议自动配置。可以学习 NAT 公共 IP 地址，并在 NAT 转换表中增删端口映射。\n    >\n    > 方案三：中继（如 Skype）NAT 内部客户-  中继 - NAT 外部客户；中继服务器桥接两个连接的分组。\n\n- 地址短缺问题应该由  IPv6 解决\n\n\n\n## 互联网控制报文协议 ICMP\n\nICMP 协议支持主机或路由器：差错或异常报告；网络探询；\n\n**两类 ICMP 报文**：\n\n- 差错报告报文\n\n    1. 目的不可达\n\n        > 路由器无法为一个数据报找到路由或主机无法交付一个数据报，然后丢弃数据报\n\n    2. 源抑制\n\n        >  拥塞控制的一种方法：警告源节点，在路径中的某处出现了拥塞，源节点必须放慢(抑制)发送过程\n\n    3. 超时/超期\n\n        > TTL = 0 或\n        >\n        > 目的结点在规定的时间内没有收到一个分组的所有分片\n\n    4. 参数问题\n\n        > 路由器或目的节点发现数据报首部中的字段值出错(二义性)，丢弃该数据报\n\n    5. 重定向\n\n        > 路由器发现这个 IP 数据报不应该由自己转发，则向源主机发送重定向报文，请求重定向\n\n- 网络探询报文\n    1. 回声（Echo）请求与应答报文（Reply）\n    2. 时间戳请求与应答报文\n\n> 由于 ICMP 报文可能需要经过几个网络才能到达源节点，ICMP 报文被封装在IP包中传输。\n>\n> ICMP 通常被认为是 IP 协议的一部分，因为 IP 协议使用 ICMP 向源节点发送错误报告。\n>\n> **Ping 利用 ICMP 报文测试目的主机是否活跃**，以及去往目的主机的路径是否正常：\n>\n> - 源主机发送 Type=8，Code=0 的 Echo Request 报文\n> - 若目的主机收到，发送 Type=0，Code=0 的 Echo Response 报文\n>     源主机计算并报告 RTT\n> - 若源主机连续几次超时（收不到Echo Response），向调用者报告目的不可达\n\n**不产生 ICMP 差错报文情形：**\n\n- 对于携带 ICMP 差错报文的数据报，不再产生 ICMP 差错报文\n- 对于分片的数据报，如果**不是第一个分片**，则不产生 ICMP 差错报文\n- 对于具有**组播(也称多播)地址**的数据报，不产生 ICMP 差错报文\n- 对于具有**特殊地址**(如 127.0.0.0 或 0.0.0.0 )，不产生 ICMP 差错报文\n\n**ICMP 报文格式：**\n\n  {% asset_img 7.PNG This is an ICMPimage %}\n\n  {% asset_img 8.PNG This is an ICMP-2 image %}\n\n\n\n## IPv6\n\n**动机：**\n\n- 32 位 IPv4 地址空间已经分配殆尽\n- 改进首部格式：快速处理、转发数据报；支持 QoS；\n\n**IPv6 与 IPv4 不兼容，但与其它所有因特网协议都兼容。**\n\n### IPv6 数据报格式\n\n- 固定长度的 40 字节基本首部\n\n- **不允许分片**\n\n  {% asset_img 9.PNG This is an ipv6 image %}\n\n### IPv6 地址\n\n128 位，使用冒号十六进制表示，每 16 位以十六进制的形式写成一组，组之间用冒号分隔，如 `8000:0:0:0:0123:4567:89AB:CDEF`\n\n地址表示的零压缩技术：可将连续的多组 0 压缩为一对冒号，如以上地址可表示为：``8000::0123:4567:89AB:CDEF`\n\nIPv6定义了三种地址类型：\n\n- 单播地址：一个特定的网络接口（一对一通信）\n- 多播地址：一组网络接口（一对多通信）\n- 任播地址（anycast）：一组网络接口中的任意一个（通常是最近的一个）\n\n### IPv6 vs. IPv4\n\n与IPv4固定头相比，IPv6的基本头中去掉了以下一些字段：\n\n- IHL：IPv6的基本头总是40字节长\n\n- 与分片相关的字段：**IPv6路由器不负责分片**\n\n- 头校验：计算校验和太花时间；现在的网络非常可靠，并且链路层和传输层上往往又都有校验和\n\n\n\nIPv6基本头中增加了：\n\n- 流标签：支持对数据包区分处理\n\n\n\n改变了以下字段的作用：\n\n- Type of Service：代之以 Traffic Class\n\n- 总长度：代之以载荷长度\n\n- Protocol：代之以Next header，允许任意扩展选项\n\n\n\n**IPv6 数据包如何穿越 IPv4 网络？**\n\n1. 报头转换\n\n    IPv4/IPv6节点（如路由器 B）在将数据报传递给 IPv4 路由器（如路由器 C）之前，将 IPv6 报头转换成 IPv4 报头\n    **缺点**：报头转换不完全，有信息丢失。\n\n2. 建立隧道\n    IPv6/IPv4 边界路由器将 IPv6 包封装到一个 IPv4 包中，送入 IPv4 网络，目的边界路由器取出IPv6包继续传输。\n    **优点**：保留原始数据报的全部信息。\n\n    {% asset_img 10.PNG This is an ipv6-ipv4 image %}\n\n\n\n# 路由算法\n\n路由算法也就是解决选路问题的算法。\n\n选路问题：给定一组路由器和连接路由器的链路，寻找一条从源路由器到目的路由器的最佳路径。\n\n学过数据结构之后我们知道，计算机网络中的路由器网络可以抽象成图模型。\n\n- 顶点：路由器\n- 边：链路\n- 边权：链路费用（可以是带宽的倒数、拥塞程度等）\n\n- **关键问题：源到目的的最小费用路径 == 最短路径问题**\n\n\n\n## 路由算法的分类\n\n1. 静态路由：\n\n    手工配置；路由更新慢；优先级高；\n\n2. 动态路由：\n\n    路由更新快，能定期更新且及时响应链路费用或网络拓扑变化。\n\n3. 全局算法：\n\n    所有路由器掌握完整的网络拓扑和链路费用信息。\n\n    e.g. 链路状态（LS ）路由算法。\n\n4. 分布式算法：\n\n    路由器只掌握物理相连的邻居及链路费用；\n\n    邻居间信息交换、运算的迭代过程；\n\n    e.g. 距离向量（DV）路由算法。\n\n## 链路状态（Link State）路由算法\n\n**基于图的最短路径算法 – Dijkstra 算法，得到源点到其他所有顶点的最短路径。**\n\n1. 所有节点（路由器）掌握网络拓扑和链路费用\n2. 计算一个结点（源）到所有顶点的最短路径\n3. 迭代：经过 k 次迭代后，得到到达 k 个目的结点的最短路径\n\n``` c\n// Dijkstra 算法\nInitialization:\n    N’ = {u}      // N’为已找到最短路径的节点集合，初始时只有u\n    for all nodes v    //标记源节点u到各个节点v的路径代价D(v)\n      if v adjacent to u\n          then D(v) = c(u,v)   //c(u,v)为链路(u,v)的代价\n      else D(v) = ∞\n\n   Loop\n     find w not in N’ such that D(w) is a minimum  //下一条最短路径\n    add w to N’     //将找到最短路径的节点加入N’\n    update D(v) for all v adjacent to w and not in N’ :\n       D(v) = min( D(v), D(w) + c(w,v) )    //更新到相关节点的路径代价\n    until all nodes in N'\n```\n\n{% asset_img 13.PNG This is an dijkstra image %}\n\n**震荡现象：** 若 A 是目的地，则下面这种情况下，最短路径循环变化，有可能一个数据报永远也到达不了 A。\n\n{% asset_img 14.PNG This is an dijkstra-problem image %}\n\n解决办法：引入路由延迟更新算法。\n\n\n\n## 距离向量（Distance Vector）路由算法\n\n**基于 bellman-ford 算法，得到源点到所有点的最短路径。**\n\n\n\n{% asset_img 15.PNG This is an bellman-ford image %}\n\n\n\n**特点：对每个路由器来说，只需要知道其邻居及其链路费用即可。**\n\n\n\n$D_x(y)$：从结点 x 到结点 y 的最小费用估计\n\n- x 维护距离向量 DV：$DV = \\{D_x(y):y\\in N\\}$\n\n结点 x：\n\n- 已知到达每个邻居的费用 c(x,v)\n- 维护其所有邻居 v 的距离向量：$DV = \\{D_v(y):y\\in N\\}$\n\n**核心思想**：\n\n- 每个节点不定时的将自身 DV 估计发送给邻居\n\n- 当 x 接收到最新的 DV 估计时，根据 B-F 方程更新自身的距离向量估计：\n\n    $D_x(y) <- ~~min_v \\{c(x,v) + D_v(y) ~for ~each~node~y\\in N\\}$\n\n- $D_x(y)$ 将**最终收敛于**实际最小费用 $d_x(y)$\n\n\n\n**无穷计数问题：好消息传播快，坏消息传播慢。**\n\n{% asset_img 16.PNG This is an bellman-ford-problem image %}\n\n\n\n**消除无穷计数问题：**\n\n1. 毒性逆转：\n\n    {% asset_img 17.PNG This is an bellman-ford-problem image %}\n\n2. 定义最大度量：\n\n    定义一个最大的有效费用值，如 15 跳，16 跳表示无穷大。\n\n    {% asset_img 18.PNG This is an mmd image %}\n\n    无穷计数不会真正的无穷下去，会在有限的步数内反应网络状态。比如上图中的 R1,R2 已经不可达了。\n\n## 层次路由\n\n将任意规模的网络抽象成一张图，这样计算路由过于理想化。\n\n在实际（大规模）网络中不可行：\n\n> 1. 路由表几乎无法存储；\n> 2. 路由计算过程的信息交换量巨大，会淹没电路。\n\n考虑网络管理自治性的问题：每个网络的管理可能都期望自主控制内部路由算法。\n\n### 自治系统 AS（autonomous systems）\n\n聚合路由器为一个区域：自治系统。\n\n同一个 AS 内的路由器运行相同的路由协议（算法）。\n\n- 自治系统内部路由协议\n- 不同的 AS 内的路由器可以运行不同的 AS 内部路由协议\n\n网关路由器：\n\n- 在 AS 边缘\n- 通过链路连接其他的 AS 网关路由器\n\n互连的 AS：\n\n- 转发表由 AS 内部路由算法与 AS 间路由算法共同设置。\n\n{% asset_img 19.PNG This is an AS image %}\n\n**举个栗子：**\n\n{% asset_img 20.PNG This is an eg-1 image %}\n\n{% asset_img 21.PNG This is an eg-2 image %}\n\n热土豆路由协议：选择最近的网关路由器。\n\n{% asset_img 22.PNG This is an eg-3 image %}\n\n\n\n# 路由协议\n\nInternet 采用层次路由。\n\nAS 内部路由协议也称内部网关协议IGP（Interior Gateway Protocols），\n\n最常见的有:\n\n- 路由信息协议 RIP（Routing Information Protocol）：较低层ISP和企业网中使用\n- 开放最短路径优先协议 OSPF（Open Shortest Path First）：较顶层 ISP 中使用\n\n外部网关协议 EGP（Exterior Gateway Protocols），目前只有： BGP（Border Gateway Protocol）\n\n## RIP\n\nRIP 采用**距离矢量选路算法**：\n\n- 距离度量：跳步数（MAX = 15 hops），每条链路一个跳步。\n- RIP 响应报文（RIP通告）\n    距离向量封装在RIP响应报文中传输；\n    每个报文携带一个目的子网列表（最多包含25个子网），以及到每个目的子网的最短距离；\n\n- RIP 响应报文的发送：\n    相邻路由器之间大约每 30 秒交换一次 RIP 响应报文\n    RIP 报文封装在 UDP 报文中发送，使用 UDP 端口 520\n\n    > RIP是一个应用层协议，其路由表示利用一个称作 route-d（daemon）的应用层进程进行管理。\n    >\n    > RIP：是应用层协议，但完成的是网络层功能。\n\n**RIP 链路的失效和恢复：**\n\n- 经过该邻居的路由不可用：需要重新计算路由\n\n- 向邻居发送新的通告\n\n- 若转发表改变，邻居再依次向外发送通告\n\n- 链路失效信息能否快速传播到全网？\n\n    可能发生无穷计数问题，但因为规定了最大跳数，故而可以在有限时间内收敛到正确状态。\n\n- **毒性逆转技术** 用于预防乒乓环路。\n\n> RIP 认为 15 跳步以内有效，16跳步及以上则认为网络不可达。所以 RIP 适用于小规模的自治系统，超过 15 跳的自治网络就不再适用了。\n\n## OSPF （Open Shortest Path First）\n\n**特点：**\n\n开放，公众可用；\n\n采用链路状态路由算法：\n\n1. LS 分组扩散（通告）\n2. 每个路由器构造完整的网络（AS）拓扑图\n3. 利用 Dijkstra 算法计算路由\n\nOSPF 通告中每个入口对应一个邻居；\n\nOSPF 通告在整个 AS 范围内泛洪，其报文直接封装到 IP 数据报中。\n\n与 OSPF 及其相似的路由协议： IS-IS 路由协议。\n\n## BGP – 自治系统间的路由选择\n\n用于确定跨越多个 AS 的源和目的对之间的路径。\n\n","tags":["计算机网络"],"categories":["复习笔记"]}]